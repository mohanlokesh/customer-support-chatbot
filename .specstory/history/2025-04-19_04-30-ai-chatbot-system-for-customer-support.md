<!-- Generated by SpecStory -->

# AI Chatbot System for Customer Support (2025-04-19 10:00:53)

_**User**_

Create an AI-driven chatbot system for customer support/e-commerce that understands user queries, retrieves answers from a database, and learns from interactions.

## Core Features
- User authentication (login/register)
- Real-time chat interface
- Query resolution via PostgreSQL database
- Natural language understanding with Rasa
- Custom actions to integrate with database
- Order tracking and item lookup
- Conversation history

## Technology Stack
- Frontend: Streamlit 2.0+
- Backend: Flask 3.0+
- NLP: Rasa 3.6+
- Database: PostgreSQL
- Python 3.10+ (latest stable)

## Database Schema
1. Users:
   - id, username, email, password_hash, created_at, last_login, is_active

2. Conversations:
   - id, user_id, start_time, end_time, duration

3. Messages:
   - id, conversation_id, is_user, content, timestamp

4. Orders:
   - id, order_number, user_id, total_amount, status (enum: pending, processing, shipped, delivered, cancelled, backordered)
   - ordered_at, estimated_delivery, delivered_at, shipping_address, tracking_number

5. OrderItems:
   - id, order_id, product_name, quantity, price

6. Company:
   - id, name, description, contact_email, contact_phone, website

7. SupportData:
   - id, company_id, question, answer, category, created/updated timestamps

## Implementation Details

### Authentication System
- JWT-based authentication
- Password hashing with bcrypt
- Login/register forms in Streamlit

### Chat System
- Real-time message display in Streamlit
- Message history persistence in database
- Dynamic conversation management

### Rasa NLP Component
- Training data with intents: greet, goodbye, ask_order_status, ask_return_policy, etc.
- Entities: order_number, email
- Custom actions:
  1. action_check_order_status - Query order status from database
  2. action_list_order_items - List items in an order
  3. action_get_user_orders - Get all orders for a user

### System Architecture
- Independent components (backend, frontend, Rasa) that can run separately
- RESTful API for frontend-backend communication
- API endpoints for:
  1. User authentication
  2. Message handling
  3. Order information
  4. Conversation management

### Integration Points
- Backend connects to PostgreSQL for data persistence
- Rasa connects to PostgreSQL for order lookup
- Frontend communicates with backend via REST API
- All components configured via environment variables

## Deployment Notes
- Environment variables for configuration
- Data persistence with PostgreSQL
- System designed to scale horizontally
- Components can be containerized

The implementation should follow modern Python best practices with type hints, proper error handling, and comprehensive logging.

---

_**Assistant**_

I'll create a complete AI-driven chatbot system as requested. Let's start by setting up the project structure.

---

```bash
mkdir -p ai_chatbot/{frontend,backend,nlp,database}
```

```
    + FullyQualifiedErrorId : CommandNotFoundException
```

---

Let me try with a different approach for Windows:

---

```bash
mkdir -p ai_chatbot\frontend ai_chatbot\backend ai_chatbot\nlp ai_chatbot\database
```

```
    + FullyQualifiedErrorId : CommandNotFoundException
```

---

Let me try with normal Windows mkdir command:

---

```bash
mkdir ai_chatbot ai_chatbot\frontend ai_chatbot\backend ai_chatbot\nlp ai_chatbot\database
```

```
    + FullyQualifiedErrorId : CommandNotFoundException
```

---

Let me try PowerShell's New-Item cmdlet:

---

```bash
New-Item -Path ai_chatbot -ItemType Directory; New-Item -Path ai_chatbot\frontend, ai_chatbot\backend, ai_chatbot\nlp, ai_chatbot\database -ItemType Directory
```

```
    + FullyQualifiedErrorId : CommandNotFoundException
```

---

Let me try to create the directory structure manually using the edit_file tool for each needed file:

---

```diff
- 
+ # AI Chatbot System Requirements
+ # Frontend
+ streamlit>=2.0.0
+ streamlit-chat>=0.1.1
+ 
+ # Backend
+ Flask>=3.0.0
+ Flask-RESTful>=0.3.10
+ Flask-Cors>=4.0.0
+ Flask-JWT-Extended>=4.5.0
+ bcrypt>=4.0.1
+ python-dotenv>=1.0.0
+ gunicorn>=21.2.0
+ 
+ # Database
+ psycopg2-binary>=2.9.9
+ SQLAlchemy>=2.0.0
+ alembic>=1.12.0
+ 
+ # NLP
+ rasa>=3.6.0
+ spacy>=3.6.0
+ 
+ # Utilities
+ requests>=2.31.0
+ loguru>=0.7.0
+ pydantic>=2.0.0
+ pytest>=7.4.0
+ 
+ # Security
+ cryptography>=41.0.0 
```

---

Now let's create the database schema and migration scripts:

---

```diff
- 
+ from datetime import datetime
+ from enum import Enum
+ from sqlalchemy import Column, Integer, String, Float, DateTime, ForeignKey, Boolean, Text, Enum as SQLEnum
+ from sqlalchemy.ext.declarative import declarative_base
+ from sqlalchemy.orm import relationship
+ 
+ Base = declarative_base()
+ 
+ class OrderStatus(str, Enum):
+     PENDING = "pending"
+     PROCESSING = "processing"
+     SHIPPED = "shipped"
+     DELIVERED = "delivered"
+     CANCELLED = "cancelled"
+     BACKORDERED = "backordered"
+ 
+ class User(Base):
+     __tablename__ = "users"
+ 
+     id = Column(Integer, primary_key=True)
+     username = Column(String(50), unique=True, nullable=False)
+     email = Column(String(100), unique=True, nullable=False)
+     password_hash = Column(String(128), nullable=False)
+     created_at = Column(DateTime, default=datetime.utcnow)
+     last_login = Column(DateTime, nullable=True)
+     is_active = Column(Boolean, default=True)
+ 
+     # Relationships
+     conversations = relationship("Conversation", back_populates="user", cascade="all, delete-orphan")
+     orders = relationship("Order", back_populates="user", cascade="all, delete-orphan")
+ 
+     def __repr__(self):
+         return f"<User(id={self.id}, username='{self.username}')>"
+ 
+ class Conversation(Base):
+     __tablename__ = "conversations"
+ 
+     id = Column(Integer, primary_key=True)
+     user_id = Column(Integer, ForeignKey("users.id"))
+     start_time = Column(DateTime, default=datetime.utcnow)
+     end_time = Column(DateTime, nullable=True)
+     duration = Column(Integer, nullable=True)  # in seconds
+ 
+     # Relationships
+     user = relationship("User", back_populates="conversations")
+     messages = relationship("Message", back_populates="conversation", cascade="all, delete-orphan")
+ 
+     def __repr__(self):
+         return f"<Conversation(id={self.id}, user_id={self.user_id})>"
+ 
+ class Message(Base):
+     __tablename__ = "messages"
+ 
+     id = Column(Integer, primary_key=True)
+     conversation_id = Column(Integer, ForeignKey("conversations.id"))
+     is_user = Column(Boolean, default=True)
+     content = Column(Text, nullable=False)
+     timestamp = Column(DateTime, default=datetime.utcnow)
+ 
+     # Relationships
+     conversation = relationship("Conversation", back_populates="messages")
+ 
+     def __repr__(self):
+         return f"<Message(id={self.id}, is_user={self.is_user})>"
+ 
+ class Order(Base):
+     __tablename__ = "orders"
+ 
+     id = Column(Integer, primary_key=True)
+     order_number = Column(String(20), unique=True, nullable=False)
+     user_id = Column(Integer, ForeignKey("users.id"))
+     total_amount = Column(Float, nullable=False)
+     status = Column(SQLEnum(OrderStatus), default=OrderStatus.PENDING)
+     ordered_at = Column(DateTime, default=datetime.utcnow)
+     estimated_delivery = Column(DateTime, nullable=True)
+     delivered_at = Column(DateTime, nullable=True)
+     shipping_address = Column(Text, nullable=False)
+     tracking_number = Column(String(50), nullable=True)
+ 
+     # Relationships
+     user = relationship("User", back_populates="orders")
+     order_items = relationship("OrderItem", back_populates="order", cascade="all, delete-orphan")
+ 
+     def __repr__(self):
+         return f"<Order(id={self.id}, order_number='{self.order_number}', status={self.status})>"
+ 
+ class OrderItem(Base):
+     __tablename__ = "order_items"
+ 
+     id = Column(Integer, primary_key=True)
+     order_id = Column(Integer, ForeignKey("orders.id"))
+     product_name = Column(String(100), nullable=False)
+     quantity = Column(Integer, nullable=False)
+     price = Column(Float, nullable=False)
+ 
+     # Relationships
+     order = relationship("Order", back_populates="order_items")
+ 
+     def __repr__(self):
+         return f"<OrderItem(id={self.id}, product_name='{self.product_name}', quantity={self.quantity})>"
+ 
+ class Company(Base):
+     __tablename__ = "companies"
+ 
+     id = Column(Integer, primary_key=True)
+     name = Column(String(100), nullable=False)
+     description = Column(Text, nullable=True)
+     contact_email = Column(String(100), nullable=False)
+     contact_phone = Column(String(20), nullable=False)
+     website = Column(String(100), nullable=True)
+ 
+     # Relationships
+     support_data = relationship("SupportData", back_populates="company", cascade="all, delete-orphan")
+ 
+     def __repr__(self):
+         return f"<Company(id={self.id}, name='{self.name}')>"
+ 
+ class SupportData(Base):
+     __tablename__ = "support_data"
+ 
+     id = Column(Integer, primary_key=True)
+     company_id = Column(Integer, ForeignKey("companies.id"))
+     question = Column(Text, nullable=False)
+     answer = Column(Text, nullable=False)
+     category = Column(String(50), nullable=False)
+     created_at = Column(DateTime, default=datetime.utcnow)
+     updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
+ 
+     # Relationships
+     company = relationship("Company", back_populates="support_data")
+ 
+     def __repr__(self):
+         return f"<SupportData(id={self.id}, category='{self.category}')>" 
```

---

Now let's create the database configuration file:

---

```diff
- 
+ import os
+ from sqlalchemy import create_engine
+ from sqlalchemy.orm import sessionmaker, scoped_session
+ from sqlalchemy.ext.declarative import declarative_base
+ from dotenv import load_dotenv
+ 
+ # Load environment variables
+ load_dotenv()
+ 
+ # Database connection settings
+ DB_USER = os.getenv("DB_USER", "postgres")
+ DB_PASSWORD = os.getenv("DB_PASSWORD", "postgres")
+ DB_HOST = os.getenv("DB_HOST", "localhost")
+ DB_PORT = os.getenv("DB_PORT", "5432")
+ DB_NAME = os.getenv("DB_NAME", "ai_chatbot")
+ 
+ # Create database URL
+ DATABASE_URL = f"postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}"
+ 
+ # Create engine
+ engine = create_engine(DATABASE_URL, pool_pre_ping=True)
+ 
+ # Create session factory
+ session_factory = sessionmaker(bind=engine)
+ SessionLocal = scoped_session(session_factory)
+ 
+ # Base class for all models
+ Base = declarative_base()
+ 
+ def get_db():
+     """
+     Dependency for getting the database session.
+     Use this as a context manager.
+     """
+     db = SessionLocal()
+     try:
+         yield db
+     finally:
+         db.close()
+ 
+ def init_db():
+     """
+     Initialize the database by creating all tables.
+     """
+     from database.models import Base
+     Base.metadata.create_all(bind=engine) 
```

---

Now let's create the database initialization script:

---

```diff
- 
+ import logging
+ from sqlalchemy.exc import SQLAlchemyError
+ from database.config import init_db, SessionLocal
+ from database.models import User, Company, SupportData, OrderStatus
+ import bcrypt
+ 
+ logging.basicConfig(level=logging.INFO)
+ logger = logging.getLogger(__name__)
+ 
+ def create_initial_data():
+     """
+     Populate the database with initial data needed for the application.
+     """
+     db = SessionLocal()
+     try:
+         # Check if we already have data
+         if db.query(User).first():
+             logger.info("Database already contains data. Skipping initialization.")
+             return
+ 
+         logger.info("Creating initial data...")
+ 
+         # Create admin user
+         hashed_password = bcrypt.hashpw("admin123".encode("utf-8"), bcrypt.gensalt()).decode("utf-8")
+         admin_user = User(
+             username="admin",
+             email="admin@example.com",
+             password_hash=hashed_password,
+             is_active=True
+         )
+         db.add(admin_user)
+ 
+         # Create test user
+         hashed_password = bcrypt.hashpw("test123".encode("utf-8"), bcrypt.gensalt()).decode("utf-8")
+         test_user = User(
+             username="testuser",
+             email="test@example.com",
+             password_hash=hashed_password,
+             is_active=True
+         )
+         db.add(test_user)
+         db.flush()  # Generate IDs for users
+ 
+         # Create company
+         company = Company(
+             name="AI Chat Support Inc.",
+             description="Leading provider of AI-powered chatbot solutions",
+             contact_email="support@aichatsupport.com",
+             contact_phone="1-800-CHATBOT",
+             website="https://aichatsupport.example.com"
+         )
+         db.add(company)
+         db.flush()  # Generate ID for company
+ 
+         # Add support data
+         support_data = [
+             SupportData(
+                 company_id=company.id,
+                 question="How do I track my order?",
+                 answer="You can track your order by logging into your account and viewing the 'Orders' section. Alternatively, you can use the tracking number sent to your email.",
+                 category="orders"
+             ),
+             SupportData(
+                 company_id=company.id,
+                 question="What is your return policy?",
+                 answer="Our return policy allows returns within 30 days of purchase. Items must be in original condition with tags attached. Please contact customer support to initiate a return.",
+                 category="returns"
+             ),
+             SupportData(
+                 company_id=company.id,
+                 question="How long does shipping take?",
+                 answer="Standard shipping typically takes 3-5 business days. Express shipping is available for 1-2 business day delivery.",
+                 category="shipping"
+             ),
+             SupportData(
+                 company_id=company.id,
+                 question="Do you ship internationally?",
+                 answer="Yes, we ship to most countries worldwide. International shipping typically takes 7-14 business days.",
+                 category="shipping"
+             ),
+             SupportData(
+                 company_id=company.id,
+                 question="How can I change my password?",
+                 answer="You can change your password by going to 'Account Settings' and selecting 'Change Password'.",
+                 category="account"
+             ),
+             SupportData(
+                 company_id=company.id,
+                 question="What payment methods do you accept?",
+                 answer="We accept all major credit cards, PayPal, and Apple Pay.",
+                 category="payment"
+             )
+         ]
+         db.add_all(support_data)
+ 
+         # Commit the changes
+         db.commit()
+         logger.info("Initial data created successfully")
+ 
+     except SQLAlchemyError as e:
+         db.rollback()
+         logger.error(f"Error creating initial data: {str(e)}")
+     finally:
+         db.close()
+ 
+ if __name__ == "__main__":
+     logger.info("Initializing database...")
+     init_db()
+     logger.info("Database initialized")
+     
+     logger.info("Creating initial data...")
+     create_initial_data()
+     logger.info("Setup complete!") 
```

---

Now let's create the backend API:

---

```diff
- 
+ import os
+ from datetime import timedelta
+ from flask import Flask, jsonify, request
+ from flask_cors import CORS
+ from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity
+ from dotenv import load_dotenv
+ import bcrypt
+ from loguru import logger
+ import sys
+ 
+ # Import database components
+ sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
+ from database.config import SessionLocal
+ from database.models import User, Conversation, Message, Order, OrderItem
+ 
+ # Load environment variables
+ load_dotenv()
+ 
+ # Create Flask app
+ app = Flask(__name__)
+ CORS(app)
+ 
+ # Configure JWT
+ app.config["JWT_SECRET_KEY"] = os.getenv("JWT_SECRET_KEY", "super-secret-key-change-in-production")
+ app.config["JWT_ACCESS_TOKEN_EXPIRES"] = timedelta(hours=1)
+ jwt = JWTManager(app)
+ 
+ # Configure logging
+ logger.add("logs/backend.log", rotation="500 MB", level="INFO")
+ 
+ @app.route("/api/health", methods=["GET"])
+ def health_check():
+     """
+     Health check endpoint
+     """
+     return jsonify({"status": "ok", "message": "Backend service is running"}), 200
+ 
+ @app.route("/api/auth/register", methods=["POST"])
+ def register():
+     """
+     Register a new user
+     """
+     data = request.get_json()
+     
+     # Validate required fields
+     required_fields = ["username", "email", "password"]
+     for field in required_fields:
+         if field not in data:
+             return jsonify({"error": f"Missing required field: {field}"}), 400
+     
+     # Check if user already exists
+     db = SessionLocal()
+     try:
+         existing_user = db.query(User).filter(
+             (User.username == data["username"]) | (User.email == data["email"])
+         ).first()
+         
+         if existing_user:
+             return jsonify({"error": "Username or email already exists"}), 409
+         
+         # Hash password
+         hashed_password = bcrypt.hashpw(data["password"].encode("utf-8"), bcrypt.gensalt()).decode("utf-8")
+         
+         # Create new user
+         new_user = User(
+             username=data["username"],
+             email=data["email"],
+             password_hash=hashed_password,
+             is_active=True
+         )
+         
+         db.add(new_user)
+         db.commit()
+         
+         # Create access token
+         access_token = create_access_token(identity=new_user.id)
+         
+         return jsonify({
+             "message": "User registered successfully",
+             "access_token": access_token,
+             "user": {
+                 "id": new_user.id,
+                 "username": new_user.username,
+                 "email": new_user.email
+             }
+         }), 201
+         
+     except Exception as e:
+         db.rollback()
+         logger.error(f"Error registering user: {str(e)}")
+         return jsonify({"error": "Failed to register user"}), 500
+     finally:
+         db.close()
+ 
+ @app.route("/api/auth/login", methods=["POST"])
+ def login():
+     """
+     Authenticate user and return JWT token
+     """
+     data = request.get_json()
+     
+     # Validate required fields
+     if not data.get("username") or not data.get("password"):
+         return jsonify({"error": "Username and password are required"}), 400
+     
+     db = SessionLocal()
+     try:
+         # Find user by username
+         user = db.query(User).filter(User.username == data["username"]).first()
+         
+         if not user or not bcrypt.checkpw(data["password"].encode("utf-8"), user.password_hash.encode("utf-8")):
+             return jsonify({"error": "Invalid username or password"}), 401
+         
+         # Update last login timestamp
+         from datetime import datetime
+         user.last_login = datetime.utcnow()
+         db.commit()
+         
+         # Create access token
+         access_token = create_access_token(identity=user.id)
+         
+         return jsonify({
+             "message": "Login successful",
+             "access_token": access_token,
+             "user": {
+                 "id": user.id,
+                 "username": user.username,
+                 "email": user.email
+             }
+         }), 200
+         
+     except Exception as e:
+         db.rollback()
+         logger.error(f"Error logging in user: {str(e)}")
+         return jsonify({"error": "Failed to authenticate user"}), 500
+     finally:
+         db.close()
+ 
+ @app.route("/api/conversations", methods=["GET"])
+ @jwt_required()
+ def get_conversations():
+     """
+     Get all conversations for the current user
+     """
+     user_id = get_jwt_identity()
+     
+     db = SessionLocal()
+     try:
+         conversations = db.query(Conversation).filter(Conversation.user_id == user_id).all()
+         
+         result = []
+         for conv in conversations:
+             # Get the last message for preview
+             last_message = db.query(Message).filter(
+                 Message.conversation_id == conv.id
+             ).order_by(Message.timestamp.desc()).first()
+             
+             result.append({
+                 "id": conv.id,
+                 "start_time": conv.start_time.isoformat() if conv.start_time else None,
+                 "end_time": conv.end_time.isoformat() if conv.end_time else None,
+                 "duration": conv.duration,
+                 "last_message": last_message.content if last_message else None,
+                 "last_message_time": last_message.timestamp.isoformat() if last_message else None
+             })
+         
+         return jsonify(result), 200
+         
+     except Exception as e:
+         logger.error(f"Error retrieving conversations: {str(e)}")
+         return jsonify({"error": "Failed to retrieve conversations"}), 500
+     finally:
+         db.close()
+ 
+ @app.route("/api/conversations", methods=["POST"])
+ @jwt_required()
+ def create_conversation():
+     """
+     Create a new conversation
+     """
+     user_id = get_jwt_identity()
+     
+     db = SessionLocal()
+     try:
+         new_conversation = Conversation(user_id=user_id)
+         db.add(new_conversation)
+         db.commit()
+         
+         return jsonify({
+             "message": "Conversation created successfully",
+             "conversation_id": new_conversation.id,
+             "start_time": new_conversation.start_time.isoformat()
+         }), 201
+         
+     except Exception as e:
+         db.rollback()
+         logger.error(f"Error creating conversation: {str(e)}")
+         return jsonify({"error": "Failed to create conversation"}), 500
+     finally:
+         db.close()
+ 
+ @app.route("/api/conversations/<int:conversation_id>/messages", methods=["GET"])
+ @jwt_required()
+ def get_messages(conversation_id):
+     """
+     Get all messages for a specific conversation
+     """
+     user_id = get_jwt_identity()
+     
+     db = SessionLocal()
+     try:
+         # Check if conversation belongs to user
+         conversation = db.query(Conversation).filter(
+             Conversation.id == conversation_id,
+             Conversation.user_id == user_id
+         ).first()
+         
+         if not conversation:
+             return jsonify({"error": "Conversation not found"}), 404
+         
+         messages = db.query(Message).filter(
+             Message.conversation_id == conversation_id
+         ).order_by(Message.timestamp.asc()).all()
+         
+         result = []
+         for msg in messages:
+             result.append({
+                 "id": msg.id,
+                 "is_user": msg.is_user,
+                 "content": msg.content,
+                 "timestamp": msg.timestamp.isoformat()
+             })
+         
+         return jsonify(result), 200
+         
+     except Exception as e:
+         logger.error(f"Error retrieving messages: {str(e)}")
+         return jsonify({"error": "Failed to retrieve messages"}), 500
+     finally:
+         db.close()
+ 
+ @app.route("/api/conversations/<int:conversation_id>/messages", methods=["POST"])
+ @jwt_required()
+ def create_message(conversation_id):
+     """
+     Create a new message in a conversation
+     """
+     user_id = get_jwt_identity()
+     data = request.get_json()
+     
+     if not data.get("content"):
+         return jsonify({"error": "Message content is required"}), 400
+     
+     db = SessionLocal()
+     try:
+         # Check if conversation belongs to user
+         conversation = db.query(Conversation).filter(
+             Conversation.id == conversation_id,
+             Conversation.user_id == user_id
+         ).first()
+         
+         if not conversation:
+             return jsonify({"error": "Conversation not found"}), 404
+         
+         # Create user message
+         new_message = Message(
+             conversation_id=conversation_id,
+             is_user=True,
+             content=data["content"]
+         )
+         db.add(new_message)
+         db.commit()
+         
+         # Return the created message
+         return jsonify({
+             "id": new_message.id,
+             "is_user": new_message.is_user,
+             "content": new_message.content,
+             "timestamp": new_message.timestamp.isoformat()
+         }), 201
+         
+     except Exception as e:
+         db.rollback()
+         logger.error(f"Error creating message: {str(e)}")
+         return jsonify({"error": "Failed to create message"}), 500
+     finally:
+         db.close()
+ 
+ @app.route("/api/orders", methods=["GET"])
+ @jwt_required()
+ def get_orders():
+     """
+     Get all orders for the current user
+     """
+     user_id = get_jwt_identity()
+     
+     db = SessionLocal()
+     try:
+         orders = db.query(Order).filter(Order.user_id == user_id).all()
+         
+         result = []
+         for order in orders:
+             result.append({
+                 "id": order.id,
+                 "order_number": order.order_number,
+                 "total_amount": order.total_amount,
+                 "status": order.status.value,
+                 "ordered_at": order.ordered_at.isoformat(),
+                 "estimated_delivery": order.estimated_delivery.isoformat() if order.estimated_delivery else None,
+                 "delivered_at": order.delivered_at.isoformat() if order.delivered_at else None,
+                 "tracking_number": order.tracking_number
+             })
+         
+         return jsonify(result), 200
+         
+     except Exception as e:
+         logger.error(f"Error retrieving orders: {str(e)}")
+         return jsonify({"error": "Failed to retrieve orders"}), 500
+     finally:
+         db.close()
+ 
+ @app.route("/api/orders/<string:order_number>", methods=["GET"])
+ @jwt_required()
+ def get_order_details(order_number):
+     """
+     Get details for a specific order
+     """
+     user_id = get_jwt_identity()
+     
+     db = SessionLocal()
+     try:
+         order = db.query(Order).filter(
+             Order.order_number == order_number,
+             Order.user_id == user_id
+         ).first()
+         
+         if not order:
+             return jsonify({"error": "Order not found"}), 404
+         
+         # Get order items
+         order_items = db.query(OrderItem).filter(OrderItem.order_id == order.id).all()
+         
+         items = []
+         for item in order_items:
+             items.append({
+                 "id": item.id,
+                 "product_name": item.product_name,
+                 "quantity": item.quantity,
+                 "price": item.price,
+                 "total": item.quantity * item.price
+             })
+         
+         result = {
+             "id": order.id,
+             "order_number": order.order_number,
+             "total_amount": order.total_amount,
+             "status": order.status.value,
+             "ordered_at": order.ordered_at.isoformat(),
+             "estimated_delivery": order.estimated_delivery.isoformat() if order.estimated_delivery else None,
+             "delivered_at": order.delivered_at.isoformat() if order.delivered_at else None,
+             "shipping_address": order.shipping_address,
+             "tracking_number": order.tracking_number,
+             "items": items
+         }
+         
+         return jsonify(result), 200
+         
+     except Exception as e:
+         logger.error(f"Error retrieving order details: {str(e)}")
+         return jsonify({"error": "Failed to retrieve order details"}), 500
+     finally:
+         db.close()
+ 
+ if __name__ == "__main__":
+     port = int(os.getenv("BACKEND_PORT", 5000))
+     app.run(host="0.0.0.0", port=port, debug=True) 
```

---

Now let's create the chatbot API endpoints in the Flask backend:

---

```diff
- 
+ import os
+ import json
+ import requests
+ from flask import Blueprint, jsonify, request
+ from flask_jwt_extended import jwt_required, get_jwt_identity
+ from sqlalchemy import or_
+ from loguru import logger
+ import sys
+ 
+ # Import database components
+ sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
+ from database.config import SessionLocal
+ from database.models import Conversation, Message, Order, OrderItem, SupportData
+ 
+ # Create blueprint
+ chatbot_bp = Blueprint('chatbot', __name__)
+ 
+ # Rasa API configuration
+ RASA_URL = os.getenv("RASA_URL", "http://localhost:5005")
+ 
+ @chatbot_bp.route("/api/chat", methods=["POST"])
+ @jwt_required()
+ def chat():
+     """
+     Process a chat message and get a response from Rasa
+     """
+     user_id = get_jwt_identity()
+     data = request.get_json()
+     
+     if not data.get("message") or not data.get("conversation_id"):
+         return jsonify({"error": "Message and conversation_id are required"}), 400
+     
+     message_text = data["message"]
+     conversation_id = data["conversation_id"]
+     
+     db = SessionLocal()
+     try:
+         # Check if conversation belongs to user
+         conversation = db.query(Conversation).filter(
+             Conversation.id == conversation_id,
+             Conversation.user_id == user_id
+         ).first()
+         
+         if not conversation:
+             return jsonify({"error": "Conversation not found"}), 404
+         
+         # Save user message
+         user_message = Message(
+             conversation_id=conversation_id,
+             is_user=True,
+             content=message_text
+         )
+         db.add(user_message)
+         db.commit()
+         
+         # Send message to Rasa
+         try:
+             rasa_payload = {
+                 "sender": str(user_id),
+                 "message": message_text
+             }
+             rasa_response = requests.post(
+                 f"{RASA_URL}/webhooks/rest/webhook",
+                 json=rasa_payload
+             )
+             
+             if rasa_response.status_code != 200:
+                 logger.error(f"Rasa API error: {rasa_response.text}")
+                 
+                 # Fallback response if Rasa is unavailable
+                 bot_message = Message(
+                     conversation_id=conversation_id,
+                     is_user=False,
+                     content="I'm sorry, I'm having trouble processing your request right now. Please try again later."
+                 )
+                 db.add(bot_message)
+                 db.commit()
+                 
+                 return jsonify({
+                     "response": "I'm sorry, I'm having trouble processing your request right now. Please try again later."
+                 }), 200
+             
+             # Process Rasa response
+             rasa_data = rasa_response.json()
+             
+             if not rasa_data:
+                 # If Rasa doesn't understand, try to find a similar question
+                 similar_data = find_similar_question(message_text)
+                 
+                 if similar_data:
+                     bot_response = similar_data.answer
+                 else:
+                     bot_response = "I'm sorry, I don't understand your question. Could you please rephrase it?"
+             else:
+                 # Use the first response from Rasa
+                 bot_response = rasa_data[0].get("text", "I'm processing your request.")
+             
+             # Save bot response
+             bot_message = Message(
+                 conversation_id=conversation_id,
+                 is_user=False,
+                 content=bot_response
+             )
+             db.add(bot_message)
+             db.commit()
+             
+             return jsonify({
+                 "response": bot_response
+             }), 200
+             
+         except requests.RequestException as e:
+             logger.error(f"Error connecting to Rasa: {str(e)}")
+             
+             # Fallback response
+             bot_message = Message(
+                 conversation_id=conversation_id,
+                 is_user=False,
+                 content="I'm sorry, I'm having trouble connecting to my backend systems right now. Please try again later."
+             )
+             db.add(bot_message)
+             db.commit()
+             
+             return jsonify({
+                 "response": "I'm sorry, I'm having trouble connecting to my backend systems right now. Please try again later."
+             }), 200
+             
+     except Exception as e:
+         db.rollback()
+         logger.error(f"Error processing chat: {str(e)}")
+         return jsonify({"error": "Failed to process chat message"}), 500
+     finally:
+         db.close()
+ 
+ @chatbot_bp.route("/api/orders/<string:order_number>/status", methods=["GET"])
+ @jwt_required()
+ def get_order_status(order_number):
+     """
+     Get the status of a specific order (used by Rasa action server)
+     """
+     user_id = get_jwt_identity()
+     
+     db = SessionLocal()
+     try:
+         order = db.query(Order).filter(
+             Order.order_number == order_number,
+             Order.user_id == user_id
+         ).first()
+         
+         if not order:
+             return jsonify({"error": "Order not found"}), 404
+         
+         return jsonify({
+             "order_number": order.order_number,
+             "status": order.status.value,
+             "ordered_at": order.ordered_at.isoformat(),
+             "estimated_delivery": order.estimated_delivery.isoformat() if order.estimated_delivery else None
+         }), 200
+         
+     except Exception as e:
+         logger.error(f"Error retrieving order status: {str(e)}")
+         return jsonify({"error": "Failed to retrieve order status"}), 500
+     finally:
+         db.close()
+ 
+ def find_similar_question(user_question, threshold=0.5):
+     """
+     Find a similar question in the support database
+     This is a simple keyword matching, in a real app this would use
+     more sophisticated NLP like embedding similarity
+     """
+     db = SessionLocal()
+     try:
+         # Convert question to lowercase and split into keywords
+         keywords = user_question.lower().split()
+         
+         # Simple approach: search for questions that contain any of the keywords
+         support_data = db.query(SupportData).filter(
+             or_(*[SupportData.question.ilike(f"%{keyword}%") for keyword in keywords])
+         ).all()
+         
+         # Return the first match if any, in a real app you would rank them by relevance
+         return support_data[0] if support_data else None
+         
+     except Exception as e:
+         logger.error(f"Error finding similar question: {str(e)}")
+         return None
+     finally:
+         db.close()
+ 
+ # Register blueprint in app.py by adding:
+ # from backend.chatbot_api import chatbot_bp
+ # app.register_blueprint(chatbot_bp) 
```

---

Now let's update the main app.py to include the chatbot blueprint:

---

```diff
  from database.config import SessionLocal
  from database.models import User, Conversation, Message, Order, OrderItem
+ from backend.chatbot_api import chatbot_bp
  
  # Load environment variables
  # Configure logging
  logger.add("logs/backend.log", rotation="500 MB", level="INFO")
+ 
+ # Register blueprints
+ app.register_blueprint(chatbot_bp)
  
  @app.route("/api/health", methods=["GET"])
```

---

Now let's create the Rasa NLP component with the necessary files for intents, entities, and custom actions:

---

```diff
- 
+ version: "3.1"
+ 
+ intents:
+   - greet
+   - goodbye
+   - thank
+   - affirm
+   - deny
+   - ask_order_status
+   - ask_return_policy
+   - ask_shipping_time
+   - ask_payment_methods
+   - ask_track_order
+   - ask_international_shipping
+   - ask_order_cancel
+   - ask_product_availability
+   - ask_create_account
+   - ask_reset_password
+   - out_of_scope
+ 
+ entities:
+   - order_number
+   - email
+   - product_name
+ 
+ slots:
+   order_number:
+     type: text
+     influence_conversation: true
+     mappings:
+     - type: from_entity
+       entity: order_number
+   email:
+     type: text
+     influence_conversation: true
+     mappings:
+     - type: from_entity
+       entity: email
+   product_name:
+     type: text
+     influence_conversation: true
+     mappings:
+     - type: from_entity
+       entity: product_name
+ 
+ responses:
+   utter_greet:
+     - text: "Hello! I'm your AI customer support assistant. How can I help you today?"
+     - text: "Hi there! Welcome to our customer service. What can I assist you with?"
+     - text: "Good day! I'm here to help with any questions about your orders or our products."
+ 
+   utter_goodbye:
+     - text: "Goodbye! Feel free to chat again if you have more questions."
+     - text: "Have a great day! Come back anytime you need assistance."
+     - text: "Thanks for chatting! I'll be here if you need more help later."
+ 
+   utter_thank:
+     - text: "You're welcome! Is there anything else I can help you with?"
+     - text: "Happy to help! Let me know if you need anything else."
+     - text: "No problem at all! Feel free to ask if you have other questions."
+ 
+   utter_affirm:
+     - text: "Great! Let's proceed."
+     - text: "Perfect! Let's continue."
+ 
+   utter_deny:
+     - text: "No problem. Is there something else I can help with?"
+     - text: "That's fine. What would you like to do instead?"
+ 
+   utter_ask_order_status_without_number:
+     - text: "I'd be happy to check your order status. Could you please provide your order number?"
+ 
+   utter_ask_track_order_without_number:
+     - text: "I can help you track your order. Please provide your order number so I can look it up."
+ 
+   utter_return_policy:
+     - text: "Our return policy allows returns within 30 days of purchase. Items must be in original condition with tags attached. Please contact customer support to initiate a return."
+ 
+   utter_shipping_time:
+     - text: "Standard shipping typically takes 3-5 business days. Express shipping is available for 1-2 business day delivery."
+ 
+   utter_payment_methods:
+     - text: "We accept all major credit cards, PayPal, and Apple Pay."
+ 
+   utter_international_shipping:
+     - text: "Yes, we ship to most countries worldwide. International shipping typically takes 7-14 business days."
+ 
+   utter_order_cancel:
+     - text: "You can cancel an order within 24 hours of placing it. Please go to your order history and select 'Cancel Order' or contact our customer service team."
+ 
+   utter_create_account:
+     - text: "To create an account, click on the 'Register' button at the top right of our website. You'll need to provide your email address and create a password."
+ 
+   utter_reset_password:
+     - text: "To reset your password, click on 'Forgot Password' on the login page. We'll send you an email with instructions to create a new password."
+ 
+   utter_out_of_scope:
+     - text: "I'm sorry, I don't understand that question. Could you please rephrase it or ask something about orders, shipping, returns, or account information?"
+     - text: "That's beyond my current capabilities. I can help with questions about orders, shipping, returns, and account management. Could you ask something in those areas?"
+ 
+ actions:
+   - action_check_order_status
+   - action_list_order_items
+   - action_get_user_orders
+   - utter_greet
+   - utter_goodbye
+   - utter_thank
+   - utter_affirm
+   - utter_deny
+   - utter_ask_order_status_without_number
+   - utter_ask_track_order_without_number
+   - utter_return_policy
+   - utter_shipping_time
+   - utter_payment_methods
+   - utter_international_shipping
+   - utter_order_cancel
+   - utter_create_account
+   - utter_reset_password
+   - utter_out_of_scope
+ 
+ session_config:
+   session_expiration_time: 60
+   carry_over_slots_to_new_session: true 
```

---

Let's create the Rasa training data:

---

```diff
- 
+ version: "3.1"
+ 
+ nlu:
+ - intent: greet
+   examples: |
+     - hey
+     - hello
+     - hi
+     - hello there
+     - good morning
+     - good evening
+     - hey there
+     - greetings
+     - howdy
+     - hi there
+     - what's up
+     - yo
+ 
+ - intent: goodbye
+   examples: |
+     - bye
+     - goodbye
+     - see you around
+     - see you later
+     - talk to you later
+     - catch you later
+     - have a nice day
+     - bye bye
+     - farewell
+     - take care
+     - until next time
+ 
+ - intent: thank
+   examples: |
+     - thanks
+     - thank you
+     - thanks a lot
+     - thank you very much
+     - I appreciate it
+     - thanks for your help
+     - that's helpful, thanks
+     - awesome, thanks
+     - great, thank you
+     - perfect, thanks
+     - appreciate your assistance
+ 
+ - intent: affirm
+   examples: |
+     - yes
+     - indeed
+     - of course
+     - that sounds good
+     - correct
+     - sure
+     - absolutely
+     - definitely
+     - yeah
+     - yep
+     - right
+     - that's right
+     - sounds good
+     - I agree
+ 
+ - intent: deny
+   examples: |
+     - no
+     - never
+     - no way
+     - not really
+     - I don't think so
+     - nope
+     - disagree
+     - I disagree
+     - not correct
+     - that's wrong
+     - nah
+     - incorrect
+ 
+ - intent: ask_order_status
+   examples: |
+     - What's the status of my order?
+     - Where is my order?
+     - I'd like to check my order status
+     - Can you tell me what's happening with my order?
+     - What's going on with my order [123456](order_number)?
+     - Check status for order [ORD-789012](order_number)
+     - Order status for [AB-123456](order_number)
+     - What's the status for [ORD987654](order_number)?
+     - Tell me about my order [AB123456](order_number)
+     - Is my order [ORDER456789](order_number) shipped yet?
+     - Has my order [12345](order_number) been delivered?
+     - What's happening with order [ABC789](order_number)?
+     - Is order [ABC-123-456](order_number) on its way?
+     - I want to know where order [ORD123456](order_number) is
+     - When will order [ORD12345](order_number) arrive?
+     - What's the delivery status of [ORDER-123](order_number)?
+     - Has order [ORD-987-654](order_number) been shipped?
+     - Give me an update on [OR123456](order_number)
+     - I want to track order [456789](order_number)
+     - Status check for order [OR-789-123](order_number)
+ 
+ - intent: ask_return_policy
+   examples: |
+     - What's your return policy?
+     - How do I return an item?
+     - Can I return a product?
+     - Tell me about your return process
+     - What's the time limit for returns?
+     - Do you accept returns?
+     - How many days do I have to return?
+     - What's your policy on returns?
+     - Can I get a refund if I return?
+     - Do I need a receipt to return?
+     - How do refunds work?
+     - Is there a restocking fee for returns?
+     - Can I return a gift?
+     - Do you cover return shipping?
+     - What is your return policy for damaged items?
+     - How long will my refund take?
+     - Return policy on sale items?
+     - Can I exchange instead of return?
+     - Do you have a no-questions-asked return policy?
+     - What's your refund policy?
+ 
+ - intent: ask_shipping_time
+   examples: |
+     - How long does shipping take?
+     - What's the delivery timeframe?
+     - When will I get my order?
+     - How many days for shipping?
+     - What's your shipping time?
+     - How long until my package arrives?
+     - Expected delivery time?
+     - Shipping duration?
+     - When should I expect delivery?
+     - How long does standard shipping take?
+     - What about express shipping?
+     - Delivery times for standard shipping?
+     - How fast is your shipping?
+     - Do you offer same-day delivery?
+     - What shipping options do you have?
+     - Fastest shipping method?
+     - Delivery timeline?
+     - How soon can I get my order?
+     - What's the shipping speed?
+     - Do you ship on weekends?
+ 
+ - intent: ask_payment_methods
+   examples: |
+     - What payment methods do you accept?
+     - How can I pay?
+     - Do you take credit cards?
+     - Can I pay with PayPal?
+     - What cards do you accept?
+     - Payment options?
+     - Do you accept Visa?
+     - Can I use Apple Pay?
+     - Payment methods available?
+     - Do you take American Express?
+     - Is Google Pay accepted?
+     - Can I pay with a gift card?
+     - Do you offer buy now pay later?
+     - Is cash on delivery available?
+     - Accepted forms of payment?
+     - Do you have payment plans?
+     - Can I use multiple payment methods?
+     - What about bank transfers?
+     - Do you accept cryptocurrency?
+     - What's your payment process?
+ 
+ - intent: ask_track_order
+   examples: |
+     - How do I track my order?
+     - I want to track my package
+     - Where is my shipment?
+     - Send me tracking information
+     - Need tracking for order [ORD456789](order_number)
+     - How to follow my delivery?
+     - Track order [ABC123](order_number)
+     - Where's my package for order [ORDER789](order_number)?
+     - Can I get tracking for [ORD-123-456](order_number)?
+     - How do I check where my package is?
+     - Need to track [ORD987654](order_number)
+     - Is there a tracking number for [AB123456](order_number)?
+     - I'd like to follow my shipment for [ORDER-XYZ](order_number)
+     - Give me tracking for [OR789123](order_number)
+     - How can I monitor my delivery?
+     - I want to see where my order [123-ABC](order_number) is
+     - Send me the tracking link for [ORDER123](order_number)
+     - How to track package from order [ORD456](order_number)?
+     - Where can I find tracking for my recent order?
+     - Tracking information for [ABC-789](order_number) please
+ 
+ - intent: ask_international_shipping
+   examples: |
+     - Do you ship internationally?
+     - Do you deliver to other countries?
+     - Can I order from outside the US?
+     - International shipping options?
+     - Do you ship to Canada?
+     - Can you ship to Europe?
+     - What countries do you ship to?
+     - Do you deliver worldwide?
+     - Global shipping available?
+     - Can I get delivery to Australia?
+     - Shipping to UK possible?
+     - Do you ship to Asia?
+     - International delivery costs?
+     - How long for international shipping?
+     - Do you have global delivery?
+     - Can you ship to Mexico?
+     - Overseas shipping options?
+     - Do you deliver outside North America?
+     - How much for international delivery?
+     - Is shipping available for all countries?
+ 
+ - intent: ask_order_cancel
+   examples: |
+     - How do I cancel my order?
+     - Can I cancel an order I just placed?
+     - I need to cancel order [ORD123456](order_number)
+     - Cancel my recent purchase
+     - How to cancel [ORDER-789](order_number)?
+     - I want to cancel my order
+     - Cancel order [AB-123-456](order_number)
+     - Is it possible to cancel [ORD987654](order_number)?
+     - Need to cancel my pending order
+     - How do I stop an order from shipping?
+     - Can I still cancel order [OR789123](order_number)?
+     - I'd like to cancel [ORDER123](order_number) please
+     - Process for cancelling an order?
+     - Need to cancel [ABC-789](order_number) immediately
+     - How long do I have to cancel my order?
+     - Can I get a refund if I cancel?
+     - Cancel [ORD456789](order_number) before shipping
+     - I made a mistake and need to cancel my order
+     - Can't proceed with order [ABC123](order_number)
+     - Need to cancel and reorder
+ 
+ - intent: ask_product_availability
+   examples: |
+     - Is [product X](product_name) in stock?
+     - Do you have [blue shirts](product_name) available?
+     - Check availability of [wireless headphones](product_name)
+     - Are [Nike Air Max](product_name) in stock?
+     - Is the [iPhone 13](product_name) available?
+     - Do you have [Xbox Series X](product_name) in store?
+     - Checking stock for [Samsung TV](product_name)
+     - Is [PS5](product_name) available now?
+     - I'm looking for [organic coffee](product_name), is it in stock?
+     - Do you have [size 10 running shoes](product_name)?
+     - Check if [vitamin C supplements](product_name) are available
+     - Is [anti-aging cream](product_name) in stock?
+     - Availability of [gaming laptop](product_name)?
+     - Do you have [wooden dining table](product_name) ready to ship?
+     - I want to buy [yoga mat](product_name), is it available?
+     - Are [AirPods Pro](product_name) in stock?
+     - Is [organic shampoo](product_name) available to order?
+     - Do you have [dog food brand X](product_name) in stock?
+     - Check if [protein powder](product_name) is available
+     - Stock status for [winter jacket](product_name)?
+ 
+ - intent: ask_create_account
+   examples: |
+     - How do I create an account?
+     - How to register?
+     - I want to sign up
+     - Can I create a new account?
+     - Registration process?
+     - How to make an account on your site
+     - Sign up instructions
+     - I need to create a login
+     - How to become a member?
+     - Account creation process?
+     - Guide to registering
+     - How do I join your site?
+     - Steps to create an account?
+     - I want to make a profile
+     - How to get started with an account
+     - New user registration?
+     - Can I create an account with my email [user@example.com](email)?
+     - How to set up an account?
+     - What's needed to create an account?
+     - Registration requirements?
+ 
+ - intent: ask_reset_password
+   examples: |
+     - How do I reset my password?
+     - Forgot my password
+     - Can't remember my login details
+     - Need to change my password
+     - Password recovery process
+     - How to recover forgotten password
+     - I can't log in
+     - Lost my password
+     - Reset password for [user@example.com](email)
+     - Password reset instructions
+     - How do I get a new password?
+     - Can't access my account
+     - Need password recovery for my email
+     - Forgot login for [username@gmail.com](email)
+     - How to get back into my account
+     - Can you reset my password?
+     - Password reset link not working
+     - How to create a new password
+     - Account recovery options
+     - I need to reset my login
+ 
+ - intent: out_of_scope
+   examples: |
+     - What's the meaning of life?
+     - Tell me a joke
+     - Can you do my homework?
+     - What's the weather like today?
+     - Who is the president?
+     - Can you order pizza for me?
+     - What's your favorite color?
+     - Sing me a song
+     - Who created you?
+     - I'm feeling sad
+     - Tell me about yourself
+     - I need medical advice
+     - What stocks should I buy?
+     - Write me a poem
+     - What do you think about politics?
+     - Can you hack a website?
+     - Who's going to win the Super Bowl?
+     - How tall are you?
+     - What's your opinion on climate change?
+     - Can we be friends? 
```

---

Now let's create the Rasa stories for conversation flow:

---

```diff
- 
+ version: "3.1"
+ 
+ stories:
+ - story: greet and goodbye
+   steps:
+   - intent: greet
+   - action: utter_greet
+   - intent: goodbye
+   - action: utter_goodbye
+ 
+ - story: greet and thank
+   steps:
+   - intent: greet
+   - action: utter_greet
+   - intent: thank
+   - action: utter_thank
+ 
+ - story: ask return policy
+   steps:
+   - intent: ask_return_policy
+   - action: utter_return_policy
+   - intent: thank
+   - action: utter_thank
+ 
+ - story: ask shipping time
+   steps:
+   - intent: ask_shipping_time
+   - action: utter_shipping_time
+ 
+ - story: ask payment methods
+   steps:
+   - intent: ask_payment_methods
+   - action: utter_payment_methods
+ 
+ - story: ask international shipping
+   steps:
+   - intent: ask_international_shipping
+   - action: utter_international_shipping
+ 
+ - story: ask order cancel
+   steps:
+   - intent: ask_order_cancel
+   - action: utter_order_cancel
+ 
+ - story: ask create account
+   steps:
+   - intent: ask_create_account
+   - action: utter_create_account
+ 
+ - story: ask reset password
+   steps:
+   - intent: ask_reset_password
+   - action: utter_reset_password
+ 
+ - story: out of scope
+   steps:
+   - intent: out_of_scope
+   - action: utter_out_of_scope
+ 
+ - story: ask order status with number
+   steps:
+   - intent: ask_order_status
+     entities:
+     - order_number: "ORD123456"
+   - action: action_check_order_status
+ 
+ - story: ask order status without number
+   steps:
+   - intent: ask_order_status
+   - action: utter_ask_order_status_without_number
+ 
+ - story: ask track order with number
+   steps:
+   - intent: ask_track_order
+     entities:
+     - order_number: "ORD123456"
+   - action: action_check_order_status
+ 
+ - story: ask track order without number
+   steps:
+   - intent: ask_track_order
+   - action: utter_ask_track_order_without_number
+ 
+ - story: complete order status flow
+   steps:
+   - intent: greet
+   - action: utter_greet
+   - intent: ask_order_status
+   - action: utter_ask_order_status_without_number
+   - intent: ask_order_status
+     entities:
+     - order_number: "ORD123456"
+   - action: action_check_order_status
+   - intent: thank
+   - action: utter_thank
+   - intent: goodbye
+   - action: utter_goodbye
+ 
+ - story: complete tracking flow
+   steps:
+   - intent: greet
+   - action: utter_greet
+   - intent: ask_track_order
+   - action: utter_ask_track_order_without_number
+   - intent: ask_track_order
+     entities:
+     - order_number: "ORD123456"
+   - action: action_check_order_status
+   - intent: thank
+   - action: utter_thank
+ 
+ - story: ask order items
+   steps:
+   - intent: ask_order_status
+     entities:
+     - order_number: "ORD123456"
+   - action: action_check_order_status
+   - intent: ask_track_order
+     entities:
+     - order_number: "ORD123456"
+   - action: action_list_order_items
+ 
+ - story: get user orders
+   steps:
+   - intent: greet
+   - action: utter_greet
+   - action: action_get_user_orders
+   - intent: ask_order_status
+     entities:
+     - order_number: "ORD123456"
+   - action: action_check_order_status 
```

---

Now let's create the Rasa custom actions for integrating with the database:

---

```diff
- 
+ import json
+ import logging
+ import os
+ import requests
+ from typing import Any, Dict, List, Text
+ from datetime import datetime
+ 
+ from rasa_sdk import Action, Tracker
+ from rasa_sdk.executor import CollectingDispatcher
+ from rasa_sdk.events import SlotSet
+ 
+ # Configure logging
+ logging.basicConfig(level=logging.INFO)
+ logger = logging.getLogger(__name__)
+ 
+ # Backend API configuration
+ BACKEND_URL = os.getenv("BACKEND_URL", "http://localhost:5000")
+ 
+ class ActionCheckOrderStatus(Action):
+     """
+     Action to check the status of a specific order.
+     """
+     def name(self) -> Text:
+         return "action_check_order_status"
+ 
+     def run(self,
+             dispatcher: CollectingDispatcher,
+             tracker: Tracker,
+             domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
+         
+         # Get the order number from the slot
+         order_number = tracker.get_slot("order_number")
+         
+         if not order_number:
+             dispatcher.utter_message(text="I'll need your order number to check the status. Could you please provide it?")
+             return []
+         
+         try:
+             # Get user ID from sender ID (requires user authentication in the backend)
+             user_id = tracker.sender_id
+             
+             # Get JWT token (in a real implementation, this would be handled by the frontend/middleware)
+             # For demo purposes, we're assuming the user is already authenticated
+             headers = {
+                 "Authorization": f"Bearer {user_id}"  # In a real app, this would be a JWT token
+             }
+             
+             # Call backend API to get order status
+             response = requests.get(
+                 f"{BACKEND_URL}/api/orders/{order_number}/status",
+                 headers=headers
+             )
+             
+             if response.status_code == 200:
+                 order_data = response.json()
+                 
+                 # Format delivery estimate
+                 estimated_delivery = order_data.get("estimated_delivery")
+                 if estimated_delivery:
+                     # Convert ISO format to date object and format nicely
+                     delivery_date = datetime.fromisoformat(estimated_delivery.replace("Z", "+00:00"))
+                     formatted_date = delivery_date.strftime("%B %d, %Y")
+                 else:
+                     formatted_date = "not available"
+                 
+                 # Send response based on order status
+                 status = order_data.get("status")
+                 
+                 if status == "pending":
+                     msg = f"Your order {order_number} is pending. We're processing it now. " \
+                           f"Estimated delivery: {formatted_date}."
+                 elif status == "processing":
+                     msg = f"Your order {order_number} is being processed. " \
+                           f"Estimated delivery: {formatted_date}."
+                 elif status == "shipped":
+                     msg = f"Good news! Your order {order_number} has been shipped. " \
+                           f"Estimated delivery: {formatted_date}."
+                 elif status == "delivered":
+                     msg = f"Your order {order_number} has been delivered. " \
+                           f"If you haven't received it, please contact our support team."
+                 elif status == "cancelled":
+                     msg = f"Your order {order_number} has been cancelled. " \
+                           f"If you didn't cancel it, please contact our support team."
+                 elif status == "backordered":
+                     msg = f"Your order {order_number} is currently backordered. " \
+                           f"We'll ship it as soon as it's available. " \
+                           f"Estimated delivery: {formatted_date}."
+                 else:
+                     msg = f"Your order {order_number} is in status: {status}. " \
+                           f"Estimated delivery: {formatted_date}."
+                 
+                 dispatcher.utter_message(text=msg)
+                 
+                 # If the order is shipped, suggest tracking
+                 if status == "shipped":
+                     dispatcher.utter_message(text="Would you like to track your package?")
+                 
+                 return [SlotSet("order_number", order_number)]
+                 
+             elif response.status_code == 404:
+                 dispatcher.utter_message(text=f"I couldn't find an order with number {order_number}. "
+                                          "Please check the number and try again.")
+                 return [SlotSet("order_number", None)]
+                 
+             else:
+                 logger.error(f"Error from backend API: {response.text}")
+                 dispatcher.utter_message(text="I'm having trouble connecting to our order system. "
+                                         "Please try again later or contact customer support.")
+                 return []
+                 
+         except requests.RequestException as e:
+             logger.error(f"Error connecting to backend: {str(e)}")
+             dispatcher.utter_message(text="I'm having trouble connecting to our order system. "
+                                     "Please try again later or contact customer support.")
+             return []
+         except Exception as e:
+             logger.error(f"Unexpected error in action_check_order_status: {str(e)}")
+             dispatcher.utter_message(text="Sorry, something went wrong while checking your order. "
+                                     "Please try again later.")
+             return []
+ 
+ class ActionListOrderItems(Action):
+     """
+     Action to list items in a specific order.
+     """
+     def name(self) -> Text:
+         return "action_list_order_items"
+ 
+     def run(self,
+             dispatcher: CollectingDispatcher,
+             tracker: Tracker,
+             domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
+         
+         # Get the order number from the slot
+         order_number = tracker.get_slot("order_number")
+         
+         if not order_number:
+             dispatcher.utter_message(text="I'll need your order number to list the items. Could you please provide it?")
+             return []
+         
+         try:
+             # Get user ID from sender ID
+             user_id = tracker.sender_id
+             
+             # Get JWT token (in a real implementation, this would be handled by the frontend/middleware)
+             headers = {
+                 "Authorization": f"Bearer {user_id}"  # In a real app, this would be a JWT token
+             }
+             
+             # Call backend API to get order details
+             response = requests.get(
+                 f"{BACKEND_URL}/api/orders/{order_number}",
+                 headers=headers
+             )
+             
+             if response.status_code == 200:
+                 order_data = response.json()
+                 items = order_data.get("items", [])
+                 
+                 if not items:
+                     dispatcher.utter_message(text=f"Your order {order_number} doesn't have any items.")
+                     return [SlotSet("order_number", order_number)]
+                 
+                 # Create a message with all items
+                 msg = f"Here are the items in your order {order_number}:\n\n"
+                 
+                 for idx, item in enumerate(items, 1):
+                     product_name = item.get("product_name", "Unknown product")
+                     quantity = item.get("quantity", 0)
+                     price = item.get("price", 0.0)
+                     total = item.get("total", price * quantity)
+                     
+                     msg += f"{idx}. {product_name} - Quantity: {quantity}, Price: ${price:.2f}, Total: ${total:.2f}\n"
+                 
+                 msg += f"\nTotal order amount: ${order_data.get('total_amount', 0.0):.2f}"
+                 
+                 dispatcher.utter_message(text=msg)
+                 return [SlotSet("order_number", order_number)]
+                 
+             elif response.status_code == 404:
+                 dispatcher.utter_message(text=f"I couldn't find an order with number {order_number}. "
+                                         "Please check the number and try again.")
+                 return [SlotSet("order_number", None)]
+                 
+             else:
+                 logger.error(f"Error from backend API: {response.text}")
+                 dispatcher.utter_message(text="I'm having trouble connecting to our order system. "
+                                         "Please try again later or contact customer support.")
+                 return []
+                 
+         except requests.RequestException as e:
+             logger.error(f"Error connecting to backend: {str(e)}")
+             dispatcher.utter_message(text="I'm having trouble connecting to our order system. "
+                                     "Please try again later or contact customer support.")
+             return []
+         except Exception as e:
+             logger.error(f"Unexpected error in action_list_order_items: {str(e)}")
+             dispatcher.utter_message(text="Sorry, something went wrong while retrieving your order items. "
+                                     "Please try again later.")
+             return []
+ 
+ class ActionGetUserOrders(Action):
+     """
+     Action to get all orders for a user.
+     """
+     def name(self) -> Text:
+         return "action_get_user_orders"
+ 
+     def run(self,
+             dispatcher: CollectingDispatcher,
+             tracker: Tracker,
+             domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
+         
+         try:
+             # Get user ID from sender ID
+             user_id = tracker.sender_id
+             
+             # Get JWT token (in a real implementation, this would be handled by the frontend/middleware)
+             headers = {
+                 "Authorization": f"Bearer {user_id}"  # In a real app, this would be a JWT token
+             }
+             
+             # Call backend API to get all user orders
+             response = requests.get(
+                 f"{BACKEND_URL}/api/orders",
+                 headers=headers
+             )
+             
+             if response.status_code == 200:
+                 orders = response.json()
+                 
+                 if not orders:
+                     dispatcher.utter_message(text="You don't have any orders yet.")
+                     return []
+                 
+                 # Create a message with recent orders
+                 msg = "Here are your recent orders:\n\n"
+                 
+                 for idx, order in enumerate(orders[:5], 1):  # Limit to 5 most recent orders
+                     order_number = order.get("order_number", "Unknown")
+                     status = order.get("status", "Unknown")
+                     ordered_at = order.get("ordered_at", "")
+                     
+                     # Format date
+                     if ordered_at:
+                         ordered_date = datetime.fromisoformat(ordered_at.replace("Z", "+00:00"))
+                         formatted_date = ordered_date.strftime("%B %d, %Y")
+                     else:
+                         formatted_date = "Unknown date"
+                     
+                     msg += f"{idx}. Order #{order_number} - Status: {status}, Ordered on: {formatted_date}\n"
+                 
+                 if len(orders) > 5:
+                     msg += f"\n... and {len(orders) - 5} more orders."
+                 
+                 msg += "\n\nYou can ask about a specific order by providing the order number."
+                 
+                 dispatcher.utter_message(text=msg)
+                 return []
+                 
+             else:
+                 logger.error(f"Error from backend API: {response.text}")
+                 dispatcher.utter_message(text="I'm having trouble retrieving your orders. "
+                                         "Please try again later or contact customer support.")
+                 return []
+                 
+         except requests.RequestException as e:
+             logger.error(f"Error connecting to backend: {str(e)}")
+             dispatcher.utter_message(text="I'm having trouble connecting to our order system. "
+                                     "Please try again later or contact customer support.")
+             return []
+         except Exception as e:
+             logger.error(f"Unexpected error in action_get_user_orders: {str(e)}")
+             dispatcher.utter_message(text="Sorry, something went wrong while retrieving your orders. "
+                                     "Please try again later.")
+             return [] 
```

---

Now let's create the Rasa configuration file:

---

```diff
- 
+ language: en
+ 
+ pipeline:
+   - name: SpacyNLP
+     model: "en_core_web_md"
+     case_sensitive: false
+   - name: SpacyTokenizer
+   - name: SpacyFeaturizer
+   - name: RegexFeaturizer
+   - name: LexicalSyntacticFeaturizer
+   - name: CountVectorsFeaturizer
+   - name: CountVectorsFeaturizer
+     analyzer: char_wb
+     min_ngram: 1
+     max_ngram: 4
+   - name: DIETClassifier
+     epochs: 100
+     entity_recognition: true
+     constrain_similarities: true
+   - name: EntitySynonymMapper
+   - name: ResponseSelector
+     epochs: 100
+     constrain_similarities: true
+   - name: FallbackClassifier
+     threshold: 0.7
+     ambiguity_threshold: 0.1
+ 
+ policies:
+   - name: MemoizationPolicy
+   - name: RulePolicy
+   - name: UnexpecTEDIntentPolicy
+     max_history: 5
+     epochs: 100
+   - name: TEDPolicy
+     max_history: 5
+     epochs: 100
+     constrain_similarities: true 
```

---

Now let's create the Rasa endpoints configuration:

---

```diff
- 
+ action_endpoint:
+   url: "http://localhost:5055/webhook"
+ 
+ models:
+   url: ${RASA_MODEL_SERVER:}
+   wait_time_between_pulls: ${RASA_MODEL_PULL_INTERVAL:20}
+ 
+ tracker_store:
+   type: SQL
+   dialect: "postgresql"
+   url: ${DB_HOST:localhost}
+   port: ${DB_PORT:5432}
+   username: ${DB_USER:postgres}
+   password: ${DB_PASSWORD:postgres}
+   db: ${DB_NAME:ai_chatbot}
+   login_db: ${DB_NAME:ai_chatbot} 
```

---

Now let's create the frontend with Streamlit:

---

Cancelled

---

Let's create the streamlit frontend:

---

```diff
- 
+ import os
+ import json
+ import requests
+ import time
+ import datetime
+ from typing import List, Dict, Any
+ import streamlit as st
+ from streamlit_chat import message
+ from dotenv import load_dotenv
+ 
+ # Load environment variables
+ load_dotenv()
+ 
+ # Backend API URL
+ BACKEND_URL = os.getenv("BACKEND_URL", "http://localhost:5000")
+ 
+ # Configure page
+ st.set_page_config(
+     page_title="AI Customer Support Chatbot",
+     page_icon="",
+     layout="wide"
+ )
+ 
+ # Initialize session state
+ if "messages" not in st.session_state:
+     st.session_state.messages = []
+ 
+ if "conversation_id" not in st.session_state:
+     st.session_state.conversation_id = None
+ 
+ if "user_id" not in st.session_state:
+     st.session_state.user_id = None
+ 
+ if "token" not in st.session_state:
+     st.session_state.token = None
+ 
+ def make_api_request(endpoint: str, method: str = "GET", data: Dict = None, token: str = None) -> Dict:
+     """
+     Make an API request to the backend.
+     """
+     headers = {}
+     if token:
+         headers["Authorization"] = f"Bearer {token}"
+     
+     if method == "GET":
+         response = requests.get(f"{BACKEND_URL}{endpoint}", headers=headers)
+     elif method == "POST":
+         headers["Content-Type"] = "application/json"
+         response = requests.post(f"{BACKEND_URL}{endpoint}", headers=headers, json=data)
+     else:
+         raise ValueError(f"Unsupported method: {method}")
+     
+     if response.status_code >= 400:
+         st.error(f"API Error: {response.status_code} - {response.text}")
+         return {"error": response.text}
+     
+     return response.json()
+ 
+ def login(username: str, password: str) -> bool:
+     """
+     Authenticate user with the backend.
+     """
+     data = {"username": username, "password": password}
+     response = make_api_request("/api/auth/login", method="POST", data=data)
+     
+     if "error" in response:
+         return False
+     
+     # Store user info and token in session state
+     st.session_state.user_id = response["user"]["id"]
+     st.session_state.token = response["access_token"]
+     st.session_state.username = response["user"]["username"]
+     return True
+ 
+ def register(username: str, email: str, password: str) -> bool:
+     """
+     Register a new user.
+     """
+     data = {"username": username, "email": email, "password": password}
+     response = make_api_request("/api/auth/register", method="POST", data=data)
+     
+     if "error" in response:
+         return False
+     
+     # Store user info and token in session state
+     st.session_state.user_id = response["user"]["id"]
+     st.session_state.token = response["access_token"]
+     st.session_state.username = response["user"]["username"]
+     return True
+ 
+ def create_conversation() -> int:
+     """
+     Create a new conversation.
+     """
+     response = make_api_request(
+         "/api/conversations",
+         method="POST",
+         data={},
+         token=st.session_state.token
+     )
+     
+     if "error" in response:
+         st.error("Failed to create conversation")
+         return None
+     
+     return response["conversation_id"]
+ 
+ def get_chat_response(user_input: str) -> str:
+     """
+     Get a response from the chatbot.
+     """
+     # Ensure we have a conversation
+     if not st.session_state.conversation_id:
+         st.session_state.conversation_id = create_conversation()
+     
+     # Send message to backend
+     response = make_api_request(
+         "/api/chat",
+         method="POST",
+         data={
+             "message": user_input,
+             "conversation_id": st.session_state.conversation_id
+         },
+         token=st.session_state.token
+     )
+     
+     if "error" in response:
+         return "I'm having trouble connecting to my backend systems. Please try again later."
+     
+     return response["response"]
+ 
+ def get_order_history() -> List[Dict]:
+     """
+     Get order history for the current user.
+     """
+     response = make_api_request(
+         "/api/orders",
+         method="GET",
+         token=st.session_state.token
+     )
+     
+     if "error" in response:
+         return []
+     
+     return response
+ 
+ def display_login_form():
+     """
+     Display the login form.
+     """
+     st.title(" AI Customer Support Chatbot")
+     
+     # Create tabs for login and registration
+     login_tab, register_tab = st.tabs(["Login", "Register"])
+     
+     with login_tab:
+         with st.form("login_form"):
+             username = st.text_input("Username")
+             password = st.text_input("Password", type="password")
+             submit_button = st.form_submit_button("Login")
+             
+             if submit_button:
+                 if login(username, password):
+                     st.success("Login successful!")
+                     st.experimental_rerun()
+                 else:
+                     st.error("Invalid username or password")
+     
+     with register_tab:
+         with st.form("register_form"):
+             new_username = st.text_input("Username")
+             new_email = st.text_input("Email")
+             new_password = st.text_input("Password", type="password")
+             confirm_password = st.text_input("Confirm Password", type="password")
+             submit_button = st.form_submit_button("Register")
+             
+             if submit_button:
+                 if new_password != confirm_password:
+                     st.error("Passwords do not match")
+                 elif register(new_username, new_email, new_password):
+                     st.success("Registration successful!")
+                     st.experimental_rerun()
+                 else:
+                     st.error("Failed to register. Username or email may already exist.")
+ 
+ def display_chat_interface():
+     """
+     Display the chat interface.
+     """
+     # Sidebar with user info and options
+     with st.sidebar:
+         st.title(f"Welcome, {st.session_state.username}!")
+         
+         # View order history
+         if st.button("View Order History"):
+             orders = get_order_history()
+             if orders:
+                 st.subheader("Recent Orders")
+                 for order in orders:
+                     with st.expander(f"Order #{order['order_number']} - {order['status']}"):
+                         st.write(f"**Order Date:** {order['ordered_at'][:10]}")
+                         st.write(f"**Total Amount:** ${order['total_amount']}")
+                         if order['tracking_number']:
+                             st.write(f"**Tracking Number:** {order['tracking_number']}")
+             else:
+                 st.info("No orders found")
+         
+         # Start new conversation
+         if st.button("New Conversation"):
+             st.session_state.conversation_id = create_conversation()
+             st.session_state.messages = []
+             st.experimental_rerun()
+         
+         # Logout button
+         if st.button("Logout"):
+             for key in list(st.session_state.keys()):
+                 del st.session_state[key]
+             st.experimental_rerun()
+     
+     # Main chat container
+     st.title(" AI Customer Support Assistant")
+     
+     # Display chat messages
+     for i, msg in enumerate(st.session_state.messages):
+         if msg["is_user"]:
+             message(msg["content"], is_user=True, key=f"msg_{i}")
+         else:
+             message(msg["content"], key=f"msg_{i}")
+     
+     # Chat input
+     user_input = st.chat_input("Type your message here...")
+     
+     if user_input:
+         # Add user message to chat
+         st.session_state.messages.append({"content": user_input, "is_user": True})
+         
+         # Get bot response
+         bot_response = get_chat_response(user_input)
+         
+         # Add bot response to chat
+         st.session_state.messages.append({"content": bot_response, "is_user": False})
+         
+         st.experimental_rerun()
+ 
+ def main():
+     """
+     Main function to run the Streamlit app.
+     """
+     # Check if user is logged in
+     if st.session_state.token:
+         display_chat_interface()
+     else:
+         display_login_form()
+ 
+ if __name__ == "__main__":
+     main() 
```

---

Finally, let's create a .env file template for configuration:

---

```diff
- 
+ # Database Configuration
+ DB_USER=postgres
+ DB_PASSWORD=postgres
+ DB_HOST=localhost
+ DB_PORT=5432
+ DB_NAME=ai_chatbot
+ 
+ # JWT Configuration
+ JWT_SECRET_KEY=super-secret-key-change-in-production
+ 
+ # Backend Configuration
+ BACKEND_PORT=5000
+ BACKEND_URL=http://localhost:5000
+ 
+ # Frontend Configuration
+ STREAMLIT_SERVER_PORT=8501
+ 
+ # Rasa Configuration
+ RASA_URL=http://localhost:5005
+ RASA_ACTIONS_URL=http://localhost:5055
+ 
+ # Logging
+ LOG_LEVEL=INFO 
```

---

Let's create a README.md file with instructions for setting up and running the project:

---

```diff
- 
+ # AI-Driven Chatbot for Customer Support/E-commerce
+ 
+ An AI-powered chatbot system for customer support and e-commerce that understands user queries, retrieves answers from a database, and learns from interactions.
+ 
+ ## Features
+ 
+ - User authentication (login/register)
+ - Real-time chat interface
+ - Natural language understanding with Rasa
+ - PostgreSQL database integration
+ - Order tracking and product lookup
+ - Conversation history
+ - Custom actions for database interaction
+ 
+ ## Technology Stack
+ 
+ - **Frontend**: Streamlit 2.0+
+ - **Backend**: Flask 3.0+
+ - **NLP**: Rasa 3.6+
+ - **Database**: PostgreSQL
+ - **Python**: 3.10+
+ 
+ ## Project Structure
+ 
+ ```
+ ai-chatbot/
+  backend/          # Flask API server
+  database/         # PostgreSQL database models and config
+  frontend/         # Streamlit web interface
+  nlp/              # Rasa NLP component
+     actions/      # Custom actions for Rasa
+     data/         # Training data
+     models/       # Trained models (generated)
+  README.md         # Project documentation
+ ```
+ 
+ ## Setup Instructions
+ 
+ ### Prerequisites
+ 
+ - Python 3.10+
+ - PostgreSQL
+ - pip (Python package manager)
+ 
+ ### Installation
+ 
+ 1. Clone the repository:
+    ```
+    git clone https://github.com/yourusername/ai-chatbot.git
+    cd ai-chatbot
+    ```
+ 
+ 2. Create a virtual environment:
+    ```
+    python -m venv venv
+    # On Windows
+    venv\Scripts\activate
+    # On macOS/Linux
+    source venv/bin/activate
+    ```
+ 
+ 3. Install dependencies:
+    ```
+    pip install -r requirements.txt
+    ```
+ 
+ 4. Install Spacy language model:
+    ```
+    python -m spacy download en_core_web_md
+    ```
+ 
+ 5. Set up the environment variables:
+    ```
+    cp .env.example .env
+    # Edit .env with your configuration
+    ```
+ 
+ 6. Set up the database:
+    ```
+    # Create the PostgreSQL database
+    createdb ai_chatbot
+    
+    # Initialize the database
+    python -m database.init_db
+    ```
+ 
+ 7. Train the Rasa model:
+    ```
+    cd nlp
+    rasa train
+    ```
+ 
+ ## Running the Application
+ 
+ You need to run several components separately:
+ 
+ 1. Start the Flask backend server:
+    ```
+    cd backend
+    python app.py
+    ```
+ 
+ 2. Start the Rasa server:
+    ```
+    cd nlp
+    rasa run --enable-api
+    ```
+ 
+ 3. Start the Rasa actions server:
+    ```
+    cd nlp
+    rasa run actions
+    ```
+ 
+ 4. Start the Streamlit frontend:
+    ```
+    cd frontend
+    streamlit run app.py
+    ```
+ 
+ The application will be accessible at: http://localhost:8501
+ 
+ ## API Documentation
+ 
+ ### Authentication Endpoints
+ 
+ - `POST /api/auth/register` - Register a new user
+ - `POST /api/auth/login` - Authenticate user and get JWT token
+ 
+ ### Conversation Endpoints
+ 
+ - `GET /api/conversations` - Get all conversations for current user
+ - `POST /api/conversations` - Create a new conversation
+ - `GET /api/conversations/{id}/messages` - Get messages for a conversation
+ - `POST /api/conversations/{id}/messages` - Add a message to a conversation
+ 
+ ### Chat Endpoint
+ 
+ - `POST /api/chat` - Send a message to the chatbot and get a response
+ 
+ ### Order Endpoints
+ 
+ - `GET /api/orders` - Get all orders for the current user
+ - `GET /api/orders/{order_number}` - Get details for a specific order
+ - `GET /api/orders/{order_number}/status` - Get status of a specific order
+ 
+ ## Database Schema
+ 
+ 1. **Users**: id, username, email, password_hash, created_at, last_login, is_active
+ 
+ 2. **Conversations**: id, user_id, start_time, end_time, duration
+ 
+ 3. **Messages**: id, conversation_id, is_user, content, timestamp
+ 
+ 4. **Orders**: id, order_number, user_id, total_amount, status, ordered_at, estimated_delivery, delivered_at, shipping_address, tracking_number
+ 
+ 5. **OrderItems**: id, order_id, product_name, quantity, price
+ 
+ 6. **Company**: id, name, description, contact_email, contact_phone, website
+ 
+ 7. **SupportData**: id, company_id, question, answer, category, created/updated timestamps
+ 
+ ## License
+ 
+ This project is licensed under the MIT License - see the LICENSE file for details. 
```

---

Let's create a simple entry point script to run the entire application:

---

```diff
- 
+ import os
+ import sys
+ import subprocess
+ import time
+ import signal
+ import atexit
+ from dotenv import load_dotenv
+ 
+ # Load environment variables
+ load_dotenv()
+ 
+ # Global variables to store process IDs
+ processes = []
+ 
+ def start_process(command, cwd=None, env=None):
+     """Start a process and return its process object"""
+     process = subprocess.Popen(
+         command,
+         cwd=cwd,
+         env=env,
+         shell=True,
+         stdout=subprocess.PIPE,
+         stderr=subprocess.PIPE,
+         text=True
+     )
+     return process
+ 
+ def cleanup():
+     """Kill all running processes on exit"""
+     print("\nShutting down all components...")
+     for process in processes:
+         try:
+             if sys.platform == 'win32':
+                 # On Windows
+                 subprocess.call(['taskkill', '/F', '/T', '/PID', str(process.pid)])
+             else:
+                 # On Unix-like systems
+                 os.killpg(os.getpgid(process.pid), signal.SIGTERM)
+         except Exception as e:
+             print(f"Error terminating process: {e}")
+ 
+ def main():
+     """Main function to run all components of the application"""
+     # Register cleanup function to run on exit
+     atexit.register(cleanup)
+     
+     # Prepare environment
+     env = os.environ.copy()
+     
+     print("Starting AI Chatbot components...")
+     
+     # 1. Start Flask backend
+     print("Starting Flask backend...")
+     flask_process = start_process(
+         "python backend/app.py",
+         env=env
+     )
+     processes.append(flask_process)
+     print(f"Flask backend started with PID: {flask_process.pid}")
+     
+     # Wait for backend to initialize
+     time.sleep(2)
+     
+     # 2. Start Rasa server
+     print("Starting Rasa server...")
+     rasa_process = start_process(
+         "rasa run --enable-api",
+         cwd="nlp",
+         env=env
+     )
+     processes.append(rasa_process)
+     print(f"Rasa server started with PID: {rasa_process.pid}")
+     
+     # 3. Start Rasa actions server
+     print("Starting Rasa actions server...")
+     actions_process = start_process(
+         "rasa run actions",
+         cwd="nlp",
+         env=env
+     )
+     processes.append(actions_process)
+     print(f"Rasa actions server started with PID: {actions_process.pid}")
+     
+     # Wait for Rasa to initialize
+     time.sleep(5)
+     
+     # 4. Start Streamlit frontend
+     print("Starting Streamlit frontend...")
+     streamlit_process = start_process(
+         "streamlit run app.py",
+         cwd="frontend",
+         env=env
+     )
+     processes.append(streamlit_process)
+     print(f"Streamlit frontend started with PID: {streamlit_process.pid}")
+     
+     print("\nAll components started successfully!")
+     print("The application is now running at: http://localhost:8501")
+     print("Press Ctrl+C to shut down all components.")
+     
+     # Keep the script running
+     try:
+         while True:
+             # Check if any process has terminated
+             for i, process in enumerate(processes):
+                 if process.poll() is not None:
+                     # Process has terminated
+                     output, error = process.communicate()
+                     print(f"Process {process.pid} terminated with exit code: {process.returncode}")
+                     if error:
+                         print(f"Error: {error}")
+                     # Remove from the list
+                     processes.pop(i)
+                     break
+             
+             # If all processes have terminated, exit
+             if not processes:
+                 print("All processes have terminated. Exiting...")
+                 break
+             
+             # Sleep to avoid high CPU usage
+             time.sleep(1)
+     except KeyboardInterrupt:
+         # Handle Ctrl+C gracefully
+         print("\nReceived keyboard interrupt. Shutting down...")
+         cleanup()
+         sys.exit(0)
+ 
+ if __name__ == "__main__":
+     main() 
```

---

Let's create a directory structure for logs and make sure our imports work correctly:

---

```diff
- 
+ # AI Chatbot Main Package
+ # This file allows Python to treat directories as packages 
```

---

```diff
- 
+ # Database Package
+ # Contains database models, configuration and utilities 
```

---

```diff
- 
+ # Backend Package
+ # Contains Flask API server and business logic 
```

---

```diff
- 
+ # Frontend Package
+ # Contains Streamlit UI components 
```

---

```diff
- 
+ # NLP Package
+ # Contains Rasa NLP components and training data 
```

---

```diff
- 
+ # Rasa Actions Package
+ # Contains custom actions for the Rasa chatbot 
```

---

Now, let's create a logs directory to store application logs:

---

```diff
- 
+ # This file ensures that the logs/ directory is tracked by git
+ # but its contents (log files) are ignored 
```

---

Let's create a .gitignore file to ignore log files and other temporary files:

---

```diff
- 
+ # Python
+ __pycache__/
+ *.py[cod]
+ *$py.class
+ *.so
+ .Python
+ build/
+ develop-eggs/
+ dist/
+ downloads/
+ eggs/
+ .eggs/
+ lib/
+ lib64/
+ parts/
+ sdist/
+ var/
+ wheels/
+ *.egg-info/
+ .installed.cfg
+ *.egg
+ 
+ # Virtualenv
+ venv/
+ ENV/
+ env/
+ 
+ # Environment files
+ .env
+ 
+ # Log files
+ logs/*.log
+ 
+ # Rasa
+ nlp/models/*
+ nlp/.rasa/
+ 
+ # IDE
+ .idea/
+ .vscode/
+ *.swp
+ *.swo
+ 
+ # OS specific
+ .DS_Store
+ Thumbs.db
+ 
+ # Streamlit
+ .streamlit/ 
```

---

That completes the AI-driven chatbot system! Here's a summary of what we've created:

1. **Database Layer**:
   - SQLAlchemy models for users, conversations, messages, orders, and support data
   - Database configuration and initialization scripts

2. **Backend API (Flask)**:
   - RESTful API endpoints for authentication, conversations, messages, and orders
   - JWT-based authentication
   - Integration with the database
   - Chatbot API endpoints to interface with Rasa

3. **NLP Component (Rasa)**:
   - Training data with intents, entities, and examples
   - Custom actions for database integration
   - Configuration for NLU pipeline and policies
   - Domain file with responses and intents

4. **Frontend (Streamlit)**:
   - User authentication interface
   - Real-time chat interface
   - Order history display
   - Integration with the backend API

5. **Deployment and Setup**:
   - Requirements file with dependencies
   - Environment variable configuration
   - Comprehensive README with setup instructions
   - Run script to start all components

To run the system, users would:

1. Install the dependencies: `pip install -r requirements.txt`
2. Set up the database: `python -m database.init_db`
3. Train the Rasa model: `cd nlp && rasa train`
4. Start the system: `python run.py`

The system can be accessed at http://localhost:8501 and allows users to:
- Register and log in
- Chat with the AI assistant
- View order history and details
- Track orders and get support information

This AI chatbot provides a complete solution for e-commerce customer support with natural language understanding and database integration.

---

_**User**_

How to fix this 

(venv) PS D:\laragon\www\new-ai-chat\nlp> rasa run --enable-api
RasaException: Error when trying to expand the environment variables in '${RASA_MODEL_SERVER:}'. Please make sure to also set these environment variables: '['${RASA_MODEL_SERVER:}']'.@.env 

---

_**Assistant**_

The error occurs because Rasa is trying to process environment variables in your endpoints.yml file but can't expand them properly. This is happening specifically with the `${RASA_MODEL_SERVER:}` variable.

Let's fix this by modifying the endpoints.yml file:

---

```diff
    url: "http://localhost:5055/webhook"
  
- models:
-   url: ${RASA_MODEL_SERVER:}
-   wait_time_between_pulls: ${RASA_MODEL_PULL_INTERVAL:20}
+ # Remove the models section as it's not needed for local development
+ # models:
+ #   url: ${RASA_MODEL_SERVER:}
+ #   wait_time_between_pulls: ${RASA_MODEL_PULL_INTERVAL:20}
  
  tracker_store:
```

---

Also, let's make sure the DB_NAME in the tracker_store matches what's in your .env file:

---

```diff
    username: ${DB_USER:postgres}
    password: ${DB_PASSWORD:postgres}
-   db: ${DB_NAME:ai_chatbot}
-   login_db: ${DB_NAME:ai_chatbot} 
+   db: ${DB_NAME:ai_chatbot_new}
+   login_db: ${DB_NAME:ai_chatbot_new} 
```

---

Now try running Rasa again with:

```
rasa run --enable-api
```

The error should be resolved. What we've done is:

1. Commented out the models section in endpoints.yml since it's not needed for local development
2. Updated the default database name to match what's in your .env file (ai_chatbot_new)

These changes should allow Rasa to start properly without trying to process those problematic environment variables.

---

_**User**_

RasaException: Error when trying to expand the environment variables in '${DB_HOST:localhost}'. Please make sure to also set these environment variables: '['${DB_HOST:localhost}']'.

---

_**Assistant**_

It looks like Rasa is still having issues with the environment variable syntax in the endpoints.yml file. Let's modify it to use a more straightforward approach without the variable substitution syntax:

---

```diff
    type: SQL
    dialect: "postgresql"
-   url: ${DB_HOST:localhost}
-   port: ${DB_PORT:5432}
-   username: ${DB_USER:postgres}
-   password: ${DB_PASSWORD:postgres}
-   db: ${DB_NAME:ai_chatbot_new}
-   login_db: ${DB_NAME:ai_chatbot_new} 
+   url: "localhost"
+   port: 5432
+   username: "postgres"
+   password: "postgres"
+   db: "ai_chatbot_new"
+   login_db: "ai_chatbot_new" 
```

---

Now try running Rasa again with:

```
rasa run --enable-api
```

This should work now. Instead of using the environment variable substitution syntax (`${VAR:default}`), we've replaced it with direct values. This avoids the parsing issue that Rasa is having with the environment variables.

If you need to change any of these values for your specific environment, you can edit them directly in the endpoints.yml file. For example, if your PostgreSQL server uses a different password, you would change the "postgres" value in the password field.

---

_**User**_

API Error: 422 - { "msg": "Subject must be a string" }

127.0.0.1 - - [19/Apr/2025 12:00:35] "POST /api/auth/login HTTP/1.1" 200 -
127.0.0.1 - - [19/Apr/2025 12:00:45] "POST /api/conversations HTTP/1.1" 422 -
127.0.0.1 - - [19/Apr/2025 12:00:47] "POST /api/chat HTTP/1.1" 422 -
127.0.0.1 - - [19/Apr/2025 12:00:52] "GET /api/orders HTTP/1.1" 422 -


---



---

